# URI Design Best Practices for REST APIs

In RESTful API design, the **URI (Uniform Resource Identifier)** is more than just a path.
It is the **address of a resource** — the way clients navigate and interact with your system.

Poorly designed URIs lead to confusion, inconsistencies, and maintenance issues. Well-designed URIs, on the other hand, make an API **predictable, intuitive, and easy to use**.

---

## Key Principles of URI Design

### 1. **Use Nouns, Not Verbs**

- URIs represent **resources**, not actions.
- Actions should be communicated via HTTP methods (GET, POST, PUT, DELETE), not inside the URI.

✅ Good:

```
/customers/42
/orders/123/items
```

❌ Bad:

```
/getCustomer?id=42
/createOrder
```

---

### 2. **Keep URIs Simple & Predictable**

- A client should be able to **guess** the URI structure by understanding the resource model.
- Avoid unnecessary complexity or deep nesting.

✅ Good:

```
/products
/products/101
/products/101/reviews
```

❌ Bad:

```
/getAllProducts
/store/products/details/101
```

---

### 3. **Use Plural Nouns for Collections**

- Collections = plural, single resource = singular (by its identifier).
- Makes it consistent and aligns with natural language.

✅ Good:

```
/customers        → collection
/customers/42     → single resource
```

❌ Bad:

```
/customer
/customer?id=42
```

---

### 4. **Hierarchical Relationships with Sub-Resources**

- If a resource is logically contained within another, use nested URIs.

✅ Good:

```
/customers/42/orders
/orders/123/items
```

❌ Bad:

```
/getOrdersByCustomerId/42
/orderItemsForOrder123
```

---

### 5. **Use Path for Resources, Query for Filtering**

- Use **path parameters** to identify a resource.
- Use **query parameters** for filtering, sorting, and pagination.

✅ Good:

```
/products/101
/products?category=electronics&sort=price&limit=10
```

❌ Bad:

```
/getProduct?id=101
/products/category/electronics/sort/price
```

---

### 6. **Use Consistent Naming Conventions**

- Stick to **lowercase letters** and **hyphens** (`-`) to separate words.
- Avoid camelCase or underscores.

✅ Good:

```
/customer-orders
/product-categories
```

❌ Bad:

```
/CustomerOrders
/product_categories
```

---

### 7. **Avoid Deep Nesting**

- Too much nesting makes URIs hard to manage.
- Limit depth to 2–3 levels; use query parameters or links for complex relationships.

✅ Good:

```
/customers/42/orders
```

❌ Bad:

```
/customers/42/orders/123/items/5/payments/999
```

---

### 8. **Use HTTP Methods Instead of Action Words**

- Don’t encode actions like `update`, `delete`, or `create` into the URI.
- HTTP methods already carry that meaning.

✅ Good:

```
DELETE /customers/42
```

❌ Bad:

```
/customers/42/delete
```

---

### 9. **Support Pagination & Filtering**

- Collections can grow large; support query parameters for pagination.

✅ Example:

```
/products?page=2&limit=20
/customers?city=delhi
```

---

### 10. **Version Your API in the URI (or headers)**

- APIs evolve; versioning prevents breaking clients.
- Version is usually placed at the start of the path.

✅ Good:

```
/v1/customers
/v2/customers
```

❌ Bad:

```
/customers?version=1
```

---

## URI Design Checklist

Before finalizing your API URIs, ask:

- ✅ Does it use **nouns**, not verbs?
- ✅ Is it **predictable** and **consistent**?
- ✅ Are resources properly **pluralized**?
- ✅ Is **nesting kept minimal**?
- ✅ Are **query params used for filtering/pagination**?
- ✅ Is **versioning handled** cleanly?

---

## Summary

Well-designed URIs make your API:

- **Intuitive** (easy to learn by looking at a few examples).
- **Consistent** (same patterns apply across resources).
- **Future-proof** (easy to extend with filters, versions, new resources).

In your Flask projects, always design URIs before coding. Think of them as the **contract** between your backend and the world.
