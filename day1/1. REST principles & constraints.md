# REST principles & constraints — a deep, practical guide

REST is more than “HTTP + JSON”. It’s an architectural style defined by Roy Fielding in his dissertation. When done thoughtfully, RESTful design gives you APIs that are scalable, evolvable, easy to cache, and intuitive for clients. Below I’ll walk through the **constraints that make REST**, what each one means in practice, why it matters, and how you — as a Flask developer / trainer — should apply them when designing APIs. No code samples — just clear concepts and actionable guidance.

---

## Quick orientation: the goal of REST

REST (Representational State Transfer) aims to make distributed systems simple and scalable by prescribing **how components interact** (clients, servers, intermediaries). Following REST constraints improves reusability, visibility, reliability and scalability.

---

## The six core constraints (plus the optional one)

1. **Client–Server**
2. **Statelessness**
3. **Cacheable**
4. **Uniform Interface** (this one contains 4 sub-constraints)
5. **Layered System**
6. **Code on Demand** (optional)

We’ll unpack each and then cover practical design rules, pitfalls, and a checklist for Flask-based APIs.

---

## 1) Client–Server

**Idea:** separate concerns — client handles UI/user state, server handles data storage & business logic.

**Why it matters:** separation enables independent evolution: you can change your server internals (DB, framework) without breaking clients.

**Practical notes for Flask apps**

- Keep UI-specific logic out of your Flask API code. Build thin, focused APIs that return resource representations.
- Use JSON for data interchange; let clients transform/display it as needed.

---

## 2) Statelessness

**Idea:** each request from client to server must contain _all_ information to understand and process it. The server does **not** keep client session state between requests.

**Why it matters:** stateless servers scale horizontally more easily (any request can go to any host), failures are simpler to isolate, and caching behaves well.

**Practical application**

- Use tokens (JWT, opaque bearer tokens) or API keys sent in `Authorization` headers for authentication. Don’t rely on server-side session memory for API requests.
- If some state must be tracked, store it on the client or in a shared store (DB, Redis) referenced by a token.
- Make all requests self-descriptive (include content-type, auth headers, pagination params, etc.).

**Common trap:** storing significant per-client session data in-memory on a single server — breaks scaling and load balancing.

---

## 3) Cacheable

**Idea:** responses must declare themselves cacheable or non-cacheable. Well-chosen caching drastically improves performance and scalability.

**Why it matters:** reduces server load and latency — intermediaries (CDNs, proxies) can serve repeated requests.

**Practical application**

- Use proper HTTP caching headers on responses:

  - `Cache-Control` (public/private, max-age),
  - `Expires` when applicable,
  - `ETag` and `Last-Modified` with conditional requests (`If-None-Match`, `If-Modified-Since`) for efficient revalidation.

- Default: treat modifying operations (POST/PUT/PATCH/DELETE) as non-cacheable. GET responses can be cacheable if they are safe to cache.
- Patch or include `Vary` header when responses vary by `Accept` or `Authorization`.

**Flask tip:** use `Flask-Caching` or set headers explicitly in responses. Implement ETag generation for resource representations.

---

## 4) Uniform Interface (the heart of REST)

This is actually four constraints bundled under “uniform interface”:

### a) Resource identification in requests

- **Resources** (things) must be identified in URIs. Use nouns — not verbs.

  - Good: `/api/customers/123`, `/api/orders/2023-10-01`
  - Avoid: `/api/getCustomer?id=123` as the primary pattern.

### b) Resource manipulation through representations

- Clients fetch a **representation** (e.g., JSON) of a resource, modify it, then send it back to update the resource.
- Representations include media type (`Content-Type`) and possibly hypermedia links.

### c) Self-descriptive messages

- Every message contains enough information to describe how to process it (headers, content-type, links).
- Use standard HTTP methods and status codes so behavior is predictable.

### d) HATEOAS — Hypermedia As The Engine Of Application State

- Responses include links/actions so clients can discover next steps (e.g., `{"id":1, "name":"X", "links":[{"rel":"orders", "href":"/api/customers/1/orders"}]}`).
- **Practical caveat:** HATEOAS is ideal but many public APIs limit hypermedia in practice. Use HATEOAS or at least include actionable links for resources where flows are non-trivial (paginated collections, related resources, next/prev).

---

## 5) Layered System

**Idea:** the client should not need to know whether it’s talking directly to the server or to an intermediary (proxy, gateway, cache).

**Why it matters:** enables load-balancers, API gateways, WAFs, CDNs to be inserted without changing client behavior.

**Practical application**

- Design APIs assuming a gateway (Kong) or reverse proxy might be present.
- Use standard headers for forwarding (`X-Forwarded-For`, etc.) when needed (but beware of trust boundaries).

---

## 6) Code on Demand (optional)

**Idea:** servers can send executable code (e.g., JavaScript) to extend client functionality temporarily. Rarely used for Web APIs — optional.

---

## Richardson Maturity Model (how RESTful is your API?)

A useful framework to measure RESTfulness:

- **Level 0:** Single endpoint (RPC-over-HTTP).
- **Level 1:** Resources (distinct URIs for resources).
- **Level 2:** Uses HTTP verbs properly (GET/POST/PUT/DELETE, status codes).
- **Level 3:** HATEOAS — responses include hypermedia links.

Aim for Level 2 for practical, maintainable APIs. Level 3 is ideal for discoverability but costs more design effort.

---

## Practical design guidance (Flask-focused, non-code)

### Resource modeling & URIs

- Model resources as nouns and use plural resource names: `/api/products`, `/api/customers`.
- Use hierarchical relationships sparingly and only when meaningful: `/api/customers/123/orders`.
- Prefer unique identifiers in URIs (`/api/customers/{id}`); avoid exposing internal DB keys if sensitive.

### HTTP method semantics

- **GET**: safe, idempotent — fetch a resource.
- **HEAD**: like GET but retrieves only headers (useful for caching).
- **POST**: create subordinate resources or perform non-idempotent operations.
- **PUT**: idempotent update/replace a resource.
- **PATCH**: partial update (must be deterministic).
- **DELETE**: idempotent removal.

### Idempotency & safety

- Idempotent methods (PUT, DELETE) should behave the same when repeated. This matters for retries and network failures.
- POST is not idempotent by default — design accordingly (e.g., clients should not retry blindly).

### Status codes — be precise

- 200 OK — success with response body
- 201 Created — resource created; include `Location` header pointing to new resource
- 204 No Content — success with no body (good for DELETE or successful PUT when no content returned)
- 400 Bad Request — client error / validation
- 401 Unauthorized — missing/invalid auth
- 403 Forbidden — authenticated but forbidden
- 404 Not Found — resource not present
- 409 Conflict — version collisions or business conflicts
- 422 Unprocessable Entity — validation problems (useful alternative to 400)
- 5xx — server errors

### Content negotiation

- Use `Accept` and `Content-Type` headers. Support common JSON media types (application/json).
- Consider supporting `application/vnd.myapp.v1+json` for versioned media types if you follow media-type versioning.

### Versioning & evolution

- Prefer versioning in the URI (`/api/v1/customers`) or via `Accept` header. Keep the strategy consistent.
- Use backward-compatible changes where possible; announce breaking changes and deprecate gracefully.

### Pagination, filtering, sorting

- Provide robust pagination for collections:

  - Offset/limit (e.g., `?page=2&per_page=20`) or
  - Cursor-based for large/real-time sets (safer for inserts/deletes).

- Return pagination metadata and links (next/prev) in the response or headers (`Link` header).

### Partial responses & sparse fieldsets

- Allow clients to request only needed fields (e.g., `?fields=id,name,email`), reducing bandwidth.

### Rate limiting & throttling

- Apply rate limits (via gateway like Kong). Return appropriate headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After`.

### Security essentials

- Always use TLS (HTTPS).
- Prefer OAuth2 / JWT for auth; use `Authorization: Bearer <token>`.
- Validate and sanitize all inputs. Use parameterized DB queries (avoid SQL injection).
- Use principle of least privilege for tokens and API keys.
- Avoid exposing sensitive implementation details in error responses.

### Observability & reliability

- Add correlation IDs for tracing across services (pass via headers).
- Log structured JSON with request/response metadata and timing.
- Expose health-check endpoints for orchestration and load balancers.

### Documentation & discoverability

- Publish OpenAPI/Swagger docs describing endpoints, payloads, and examples.
- Provide client SDKs or code samples if helpful.

---

## HATEOAS: pros & cons

- **Pros:** clients can discover actions; reduces need for out-of-band documentation for flows.
- **Cons:** more design overhead, many clients and developers prefer explicit API docs and versioning.
- **Practical compromise:** include useful links for resources and pagination (`self`, `next`, `prev`, related resources) while relying on OpenAPI for detailed contracts.

---

## Anti-patterns to avoid

- Using verbs in URIs (e.g., `/getUser`) — makes APIs RPC-like.
- Encoding too much state in URLs or using custom headers for conventional things.
- Returning 200 for all errors (obscures issues); prefer meaningful status codes.
- Creating deeply nested URIs just to represent relationships — think whether flattening + query param is better.
- Relying on server sessions for API client state.

---

## Testing, CI, & evolution

- Use contract testing (Pact) when multiple teams own client & server.
- Apply automated tests (unit + integration) and run them in CI.
- Maintain a versioned OpenAPI spec; generate server/client stubs or docs from it.
- Use feature flags and blue/green or canary deployments for risk mitigation.

---

## Quick checklist you can hand students (or use during design)

- [ ] Are my resources nouns and URIs stable?
- [ ] Are HTTP methods used according to semantics?
- [ ] Do all responses include correct status codes?
- [ ] Are GET responses cacheable where appropriate? ETag/Last-Modified in place?
- [ ] Is the API stateless (auth via tokens, no server sessions)?
- [ ] Are write operations idempotent where they should be?
- [ ] Is pagination implemented for collections with links/meta?
- [ ] Are error responses consistent and helpful (structured error object)?
- [ ] Is TLS enforced and auth implemented securely?
- [ ] Is OpenAPI documentation available and up to date?
- [ ] Have you considered rate limiting, logging, and monitoring?

---

## Final thoughts (for Flask trainers)

- REST isn’t a checklist you finish once — it’s a set of practices that guide API design.
- For Flask lessons focus on: modeling resources, correct use of HTTP verbs/status codes, stateless auth (JWT), caching headers, and how to document with OpenAPI.
- Give learners exercises: move an RPC-style API to RESTful resources, add caching headers and ETags, and document the API with Swagger.
