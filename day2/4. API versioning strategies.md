# API Versioning Strategies in Flask

When building APIs, one of the **biggest challenges** is handling changes over time without breaking existing clients. Imagine you’ve deployed your API, and mobile apps or other services are consuming it. If you suddenly change the structure of responses or remove fields, those clients may fail.

That’s where **API versioning** comes in. Versioning allows you to evolve your API without breaking older clients. In this post, we’ll explore **API versioning strategies in Flask**, with practical examples.

---

## Why Versioning Matters

Consider a simple users API that returns:

```json
{
  "name": "Vinod",
  "email": "vinod@vinod.co"
}
```

Later, you decide to also include a `phone` field. If a client app wasn’t built to handle `phone`, it may ignore it — but what if you rename `email` to `contactEmail`? That could break existing apps.

By versioning your API, you can support both **old** and **new** clients at the same time.

---

## Common API Versioning Strategies

### 1. **URI Path Versioning**

The simplest and most common approach. Add the version number directly into the URL.

```python
@app.route('/api/v1/users')
def get_users_v1():
    return [{"name": "Vinod", "email": "vinod@vinod.co"}]

@app.route('/api/v2/users')
def get_users_v2():
    return [{"name": "Vinod", "email": "vinod@vinod.co", "phone": "123-456-7890"}]
```

Clients choose which version they want by calling `/api/v1/...` or `/api/v2/...`.

✅ Easy to implement
✅ Clear separation
❌ URLs can get cluttered

---

### 2. **Query Parameter Versioning**

Clients specify the version using a query string.

```python
@app.route('/api/users')
def get_users():
    version = request.args.get('version', '1')
    if version == '2':
        return [{"name": "Vinod", "email": "vinod@vinod.co", "phone": "123-456-7890"}]
    return [{"name": "Vinod", "email": "vinod@vinod.co"}]
```

Clients call:

- `/api/users?version=1`
- `/api/users?version=2`

✅ Simple to implement
❌ Easy to forget adding version parameter
❌ Can clutter query strings

---

### 3. **Header-Based Versioning**

Clients specify the version using a custom HTTP header.

```python
@app.route('/api/users')
def get_users():
    version = request.headers.get("X-API-Version", "1")
    if version == "2":
        return [{"name": "Vinod", "email": "vinod@vinod.co", "phone": "123-456-7890"}]
    return [{"name": "Vinod", "email": "vinod@vinod.co"}]
```

Client request example:

```bash
curl -H "X-API-Version: 2" http://localhost:5000/api/users
```

✅ Keeps URLs clean
✅ Easy to migrate clients silently
❌ Slightly harder to test manually

---

### 4. **Accept Header (Content Negotiation)**

Clients specify version in the `Accept` header.

```python
@app.route('/api/users')
def get_users():
    accept = request.headers.get("Accept", "application/json")
    if "vnd.myapi.v2+json" in accept:
        return [{"name": "Vinod", "email": "vinod@vinod.co", "phone": "123-456-7890"}]
    return [{"name": "Vinod", "email": "vinod@vinod.co"}]
```

Client request example:

```bash
curl -H "Accept: application/vnd.myapi.v2+json" http://localhost:5000/api/users
```

✅ Industry-standard approach
✅ Works well with API gateways
❌ More complex for beginners

---

## Error Handling in Versioning

It’s important to handle unsupported versions gracefully. For example, if a client asks for version `3` that doesn’t exist:

```python
if version not in ["1", "2"]:
    return {"error": "API version not supported"}, 400
```

Clients should get a **clear error message** instead of a broken response.

---

## Complete Example: URI Path Versioning

Here’s a runnable Flask app demonstrating **URI path versioning**:

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/v1/users')
def get_users_v1():
    return jsonify([
        {"name": "Vinod", "email": "vinod@vinod.co"},
        {"name": "Shyam", "email": "shyam@xmpl.com"}
    ])

@app.route('/api/v2/users')
def get_users_v2():
    return jsonify([
        {"name": "Vinod", "email": "vinod@vinod.co", "phone": "123-456-7890"},
        {"name": "Shyam", "email": "shyam@xmpl.com", "phone": "987-654-3210"}
    ])

if __name__ == '__main__':
    app.run(debug=True)
```

---

## Conclusion

API versioning is crucial for maintaining **backward compatibility** while evolving your API.

- **Path versioning** is the simplest.
- **Header-based and Accept-header strategies** are more professional and align with modern API design.
- **Query parameter versioning** is quick but less recommended for large-scale systems.

When you design APIs in Flask (or any framework), plan your **versioning strategy upfront**. This avoids painful breaking changes later and ensures a smooth experience for your clients.

---
