# Request Validation & Error Handling in Flask Application

When building web applications, one of the most important aspects is **ensuring data integrity** and **handling errors gracefully**. A Flask application without proper request validation may end up with unexpected inputs, while an app without robust error handling might confuse users with cryptic error messages.

In this post, we’ll explore how to perform request validation and error handling in a **Flask application** using practical examples.

---

## Why Request Validation Matters

Request validation ensures that the data coming into your API is clean, accurate, and follows the rules you’ve defined. Without validation, you risk:

- **Bad data in your database** (e.g., invalid emails, missing required fields).
- **Application crashes** due to unexpected input types.
- **Security vulnerabilities**, since malicious users can send invalid or malicious payloads.

---

## Setting up a Simple Flask App

Let’s create a small API where users can submit their details. For demonstration, we’ll use two users:

- **Vinod** → `vinod@vinod.co`
- **Shyam** → `shyam@xmpl.com`

### Flask Project Structure

```
flask-validation/
│
├── app.py
└── requirements.txt
```

### Basic `app.py`

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

# In-memory data store
users = [
    {"name": "Vinod", "email": "vinod@vinod.co"},
    {"name": "Shyam", "email": "shyam@xmpl.com"}
]
```

---

## Adding Request Validation

Let’s say we want to add new users. The client must send `name` and `email`. We’ll validate the request before inserting into our data store.

```python
from email_validator import validate_email, EmailNotValidError

@app.route('/users', methods=['POST'])
def add_user():
    data = request.get_json()

    # Check if required fields are present
    if not data or 'name' not in data or 'email' not in data:
        return jsonify({"error": "Name and email are required"}), 400

    # Validate email format
    try:
        validate_email(data['email'])
    except EmailNotValidError:
        return jsonify({"error": "Invalid email format"}), 400

    # Save user
    new_user = {"name": data['name'], "email": data['email']}
    users.append(new_user)

    return jsonify({"message": "User added successfully", "user": new_user}), 201
```

✅ Here, we used the **email-validator** library to check if the email is valid. If the validation fails, the API returns a `400 Bad Request` error with a clear message.

---

## Error Handling in Flask

Errors are inevitable—what matters is how we handle them. Flask allows us to define **error handlers** for specific exceptions or HTTP error codes.

### Example: Handling “Not Found” Error

If a client tries to fetch a user that doesn’t exist, we should return a **404 Not Found** error instead of a blank response.

```python
@app.route('/users/<string:name>', methods=['GET'])
def get_user(name):
    for user in users:
        if user['name'].lower() == name.lower():
            return jsonify(user)

    # User not found
    return jsonify({"error": f"User '{name}' not found"}), 404
```

If someone requests `/users/Ravi`, they’ll get:

```json
{
  "error": "User 'Ravi' not found"
}
```

---

## Global Error Handlers

Instead of handling errors in every route, you can define global error handlers:

```python
@app.errorhandler(400)
def bad_request(error):
    return jsonify({"error": "Bad Request", "message": str(error)}), 400

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Resource not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Something went wrong. Please try again later."}), 500
```

With this setup, any `400`, `404`, or `500` errors will automatically return JSON responses—making your API consistent and user-friendly.

---

## Testing the API

### Add a new user (valid request)

```bash
curl -X POST http://localhost:5000/users \
-H "Content-Type: application/json" \
-d '{"name": "Ravi", "email": "ravi@example.com"}'
```

✅ Response:

```json
{
  "message": "User added successfully",
  "user": {
    "name": "Ravi",
    "email": "ravi@example.com"
  }
}
```

### Add a new user (invalid email)

```bash
curl -X POST http://localhost:5000/users \
-H "Content-Type: application/json" \
-d '{"name": "Ravi", "email": "invalid-email"}'
```

❌ Response:

```json
{
  "error": "Invalid email format"
}
```

### Get non-existing user

```bash
curl http://localhost:5000/users/Ravi
```

❌ Response:

```json
{
  "error": "User 'Ravi' not found"
}
```

---

## Conclusion

By combining **request validation** and **error handling**, you can make your Flask applications **more reliable, secure, and user-friendly**.

- Validation ensures only clean and expected data enters your system.
- Error handling ensures that unexpected issues don’t break your app but instead return meaningful messages.

These small practices make a big difference in creating production-ready Flask applications.

---
