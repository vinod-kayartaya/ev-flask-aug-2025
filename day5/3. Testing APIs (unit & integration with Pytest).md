# Testing Flask REST APIs with Pytest (Unit & Integration)

When building REST APIs, it’s not enough to just write endpoints — you need to **test them thoroughly**.
Testing ensures:

- Your APIs return the expected responses.
- New changes don’t break existing functionality.
- Edge cases and errors are handled gracefully.

In Python, one of the most popular testing frameworks is **Pytest**.
In this tutorial, we’ll use Pytest to write **unit tests** (testing functions in isolation) and **integration tests** (testing API endpoints via HTTP).

---

## 1. Setting Up the Project

We’ll build on our **Customer API** example.
Make sure you have these installed:

```bash
pip install flask flask-sqlalchemy pytest pytest-flask
```

---

## 2. What are Unit Tests vs Integration Tests?

- **Unit Tests** → Test individual components (e.g., database model methods).
- **Integration Tests** → Test the full flow by calling the API endpoints and checking responses.

In Flask:

- Unit test = call Python functions directly.
- Integration test = use Flask’s test client to simulate API requests (`client.get()`, `client.post()`, etc.).

---

## 3. Project Structure for Tests

```
flask-testing-demo/
│
└── api/
│   ├── app.py
│   ├── models.py
│   ├── customers/
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── extensions.py
│   └── config.py
│
└── tests/
    ├── conftest.py
    ├── test_models.py
    └── test_customers_api.py
```

---

## 4. Pytest Fixtures for Test Setup

In `tests/conftest.py` we define **fixtures** (reusable setup code):

```python
import pytest
from api.app import create_app
from api.extensions import db

@pytest.fixture
def app():
    """Create and configure a new app instance for each test"""
    app = create_app()
    app.config.update({
        "TESTING": True,
        "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:",  # in-memory DB for tests
        "SQLALCHEMY_TRACK_MODIFICATIONS": False
    })

    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    """A test client for the app"""
    return app.test_client()

@pytest.fixture
def runner(app):
    """A CLI runner for the app"""
    return app.test_cli_runner()
```

**Concept:**

- `pytest.fixture` → Creates reusable components for tests.
- Here, `app` creates a **new Flask app** with an **in-memory SQLite DB** for each test (so tests don’t affect your real DB).
- `client` provides a fake HTTP client to call your APIs.

---

## 5. Writing Unit Tests for the Model

In `tests/test_models.py`:

```python
from api.models import Customer
from api.extensions import db

def test_create_customer(app):
    """Test creating and saving a Customer model"""
    with app.app_context():
        customer = Customer(
            name="Vinod",
            city="Bangalore",
            email="vinod@vinod.co",
            phone="9731424784"
        )
        db.session.add(customer)
        db.session.commit()

        saved = Customer.query.filter_by(email="vinod@vinod.co").first()
        assert saved is not None
        assert saved.name == "Vinod"
```

**Concept:**
This test **bypasses the API** and directly checks if the `Customer` model works correctly with the DB.

---

## 6. Writing Integration Tests for the API

In `tests/test_customers_api.py`:

```python
def test_create_customer(client):
    """Test POST /api/customers/"""
    response = client.post("/api/customers/", json={
        "name": "Vinod",
        "city": "Bangalore",
        "email": "vinod@vinod.co",
        "phone": "9731424784"
    })

    assert response.status_code == 201
    data = response.get_json()
    assert data["name"] == "Vinod"
    assert data["email"] == "vinod@vinod.co"


def test_list_customers(client):
    """Test GET /api/customers/"""
    # First, create a customer
    client.post("/api/customers/", json={
        "name": "Vinod",
        "city": "Bangalore",
        "email": "vinod@vinod.co",
        "phone": "9731424784"
    })

    response = client.get("/api/customers/")
    assert response.status_code == 200
    data = response.get_json()
    assert len(data) == 1
    assert data[0]["city"] == "Bangalore"
```

**Concept:**

- `client.post()` simulates an API call.
- We check both **status codes** and **response data**.
- This ensures the API works end-to-end.

---

## 7. Running the Tests

Run tests with:

```bash
PYTHONPATH=. pytest -v
```

Sample output:

```
tests/test_models.py::test_create_customer PASSED
tests/test_customers_api.py::test_create_customer PASSED
tests/test_customers_api.py::test_list_customers PASSED
```

---

## 8. Key Benefits of Testing with Pytest

✅ Catches bugs early
✅ Provides confidence when refactoring
✅ Makes your API predictable and stable
✅ Helps onboard new developers faster

You now have:

- `tests/conftest.py` → fixtures
- `tests/test_models.py` → unit test
- `tests/test_customers_api.py` → integration tests

Together, they cover **models + API routes**.

---

## 10. Summary

- Use **Pytest fixtures** to spin up a clean test app & DB.
- Write **unit tests** to test models in isolation.
- Write **integration tests** to test full API flows.
- Run tests with `pytest` and watch the green ✅ appear!
