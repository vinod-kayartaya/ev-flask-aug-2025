# Flask Blueprints for Scalable APIs

When building small Flask apps, it’s fine to keep all routes in a single `app.py`.
But as your application grows (multiple features, dozens of endpoints), a **single file becomes messy and hard to maintain**.

This is where **Flask Blueprints** come in. They let us **organize routes by feature** and keep code modular, just like Django apps or Express.js routers.

In this tutorial, we’ll build a small **Customer API** using Blueprints.

---

## 1. What are Blueprints?

Think of a Blueprint as a **mini-application** inside Flask.

- Each Blueprint can define its **own routes**, **error handlers**, and even **static files**.
- Later, we register these Blueprints on the main Flask app.
- This makes it easy to **split code by modules**: e.g., `customers`, `products`, `orders`.

---

## 2. Project Structure

Here’s the structure we’ll follow:

```
flask-blueprint-demo/
│
├── app.py                # Main entry point
├── extensions.py         # Extensions like SQLAlchemy
├── models.py             # Database models
├── customers/
│   ├── __init__.py
│   ├── routes.py         # Customer endpoints
│   └── service.py        # (Optional) Business logic
└── config.py             # Configurations
```

---

## 3. Setting up Flask with Config and Extensions

First, create `config.py`:

```python
import os

class Config:
    SQLALCHEMY_DATABASE_URI = "sqlite:///app.db"
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.environ.get("SECRET_KEY", "dev")
```

Now create `extensions.py`:

```python
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()
```

---

## 4. The Models

Create `models.py` for database models:

```python
from extensions import db

class Customer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    city = db.Column(db.String(120))
    email = db.Column(db.String(120), unique=True, nullable=False)
    phone = db.Column(db.String(20), unique=True, nullable=False)

    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "city": self.city,
            "email": self.email,
            "phone": self.phone
        }
```

---

## 5. Creating the Customer Blueprint

Inside `customers/routes.py`:

```python
from flask import Blueprint, request, jsonify
from extensions import db
from models import Customer

# Define blueprint
customers_bp = Blueprint("customers", __name__, url_prefix="/api/customers")

@customers_bp.route("/", methods=["POST"])
def create_customer():
    data = request.json
    name, city, email, phone = data.get("name"), data.get("city"), data.get("email"), data.get("phone")

    if not (name and email and phone):
        return jsonify({"error": "name, email, phone are required"}), 400

    if Customer.query.filter_by(email=email).first():
        return jsonify({"error": "email already exists"}), 409

    customer = Customer(name=name, city=city, email=email, phone=phone)
    db.session.add(customer)
    db.session.commit()

    return jsonify(customer.to_dict()), 201


@customers_bp.route("/", methods=["GET"])
def list_customers():
    customers = Customer.query.all()
    return jsonify([c.to_dict() for c in customers])


@customers_bp.route("/<int:id>", methods=["GET"])
def get_customer(id):
    customer = Customer.query.get_or_404(id)
    return jsonify(customer.to_dict())
```

**Concept:**

- `Blueprint("customers", __name__, url_prefix="/api/customers")`
  → All routes in this blueprint are prefixed with `/api/customers`.
- Each route works just like a normal Flask route.

---

## 6. Registering the Blueprint in `app.py`

Now the main application just imports and registers blueprints.

```python
from flask import Flask
from config import Config
from extensions import db
from customers.routes import customers_bp

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    db.init_app(app)

    # Register blueprints
    app.register_blueprint(customers_bp)

    with app.app_context():
        db.create_all()

    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True)
```

**Concept:**

- `create_app` is an **application factory pattern** (good for scaling).
- All blueprints are registered in one place.
- The main app doesn’t need to know all routes — they live in their own modules.

---

## 7. Testing the API

Let’s test with **sample data (Vinod)**.

### Create Customer

```bash
curl -X POST http://127.0.0.1:5000/api/customers/ \
  -H "Content-Type: application/json" \
  -d '{"name":"Vinod","city":"Bangalore","email":"vinod@vinod.co","phone":"9731424784"}'
```

### Get All Customers

```bash
curl http://127.0.0.1:5000/api/customers/
```

Response:

```json
[
  {
    "id": 1,
    "name": "Vinod",
    "city": "Bangalore",
    "email": "vinod@vinod.co",
    "phone": "9731424784"
  }
]
```

---

## 8. Why Blueprints Matter

Without Blueprints, all routes would live in `app.py`. As you add features like `products`, `orders`, or `auth`, the file grows to thousands of lines.

With Blueprints:

- `customers/routes.py` → only customer APIs
- `products/routes.py` → only product APIs
- `auth/routes.py` → only auth APIs

This separation makes your API **modular, maintainable, and scalable**.

## Summary

- Blueprints help split APIs into modules, making them **scalable and maintainable**.
- Each Blueprint defines its own routes and is registered in the main app.
- This pattern is essential for **large Flask applications**.
