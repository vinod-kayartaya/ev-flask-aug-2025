# API Gateway Integration with Kong

When you deploy multiple microservices or APIs, managing them directly can get messy:

- How do you authenticate requests?
- How do you rate limit?
- How do you centralize logging/monitoring?

This is where an **API Gateway** comes in.

An API Gateway sits between your clients (frontend/mobile) and backend services. It provides:
âœ… Centralized access to APIs
âœ… Authentication & authorization
âœ… Rate limiting, logging, caching
âœ… Request/response transformation

One popular open-source gateway is **Kong**.

---

## What is Kong Gateway?

Kong is a **cloud-native, open-source API gateway** built on Nginx.
It helps manage, monitor, and secure APIs.

With Kong you can:

- Register APIs (called **Services** in Kong).
- Expose them via **Routes**.
- Enhance them with **Plugins** (auth, rate limiting, CORS, logging, etc.).

Managing multiple APIs in a microservice architecture can get messy.
Instead of exposing each service individually, we use an **API Gateway**.

In this tutorial weâ€™ll set up:

- Two Flask APIs (Products & Customers).
- Kong Gateway in front of them.
- Declarative routing (`kong.yml`) so we donâ€™t need to configure routes manually.

The final setup:

- `http://localhost:8000/api/products` â†’ Products API
- `http://localhost:8000/api/customers` â†’ Customers API

---

## 1. Project Structure

```
kong-flask-gateway/
â”‚
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ kong.yml
â”œâ”€â”€ products/
â”‚   â”œâ”€â”€ app.py
â”‚   â””â”€â”€ Dockerfile
â””â”€â”€ customers/
    â”œâ”€â”€ app.py
    â””â”€â”€ Dockerfile
```

---

## 2. Flask Services

### `products/app.py`

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/products")
def get_products():
    return jsonify([
        {"id": 1, "name": "Laptop", "price": 50000},
        {"id": 2, "name": "Mobile", "price": 20000}
    ])

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=6010)
```

### `customers/app.py`

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/customers")
def get_customers():
    return jsonify([
        {"id": 1, "name": "Vinod", "city": "Bangalore", "email": "vinod@vinod.co", "phone": "9731424784"},
        {"id": 2, "name": "John", "city": "Delhi", "email": "john@example.com", "phone": "9812345678"}
    ])

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=6020)
```

---

## 3. Dockerfile for Flask APIs

Both services use the same simple Dockerfile.

### Example: `products/Dockerfile`

```dockerfile
FROM python:3.10-slim

WORKDIR /app
COPY app.py /app
RUN pip install flask

CMD ["python", "app.py"]
```

(Same Dockerfile works for `customers/`, just copy it into that folder.)

---

## 4. Kong Declarative Config (`kong.yml`)

Instead of running `curl` commands against the Admin API, we use a **DB-less declarative config**:

```yaml
_format_version: '3.0'

services:
  - name: products-service
    url: http://products:6010
    routes:
      - name: products-route
        paths:
          - /api/products
        strip_path: false # ðŸ‘ˆ preserve path so Flask sees /api/products

  - name: customers-service
    url: http://customers:6020
    routes:
      - name: customers-route
        paths:
          - /api/customers
        strip_path: false # ðŸ‘ˆ preserve path so Flask sees /api/customers
```

**Why `strip_path: false`?**
By default, Kong strips the route prefix before forwarding.
So `/api/customers` would be forwarded as `/` to Flask â€” leading to a **404**.
Setting `strip_path: false` ensures Kong forwards the **full path**.

---

## 5. Docker Compose (`docker-compose.yml`)

Hereâ€™s the full setup:

```yaml
version: '3.8'

networks:
  kong-net:

services:
  products:
    build: ./products
    container_name: products-service
    networks:
      - kong-net
    ports:
      - '6010:6010'

  customers:
    build: ./customers
    container_name: customers-service
    networks:
      - kong-net
    ports:
      - '6020:6020'

  kong:
    image: kong:3
    container_name: kong
    environment:
      KONG_DATABASE: 'off' # DB-less mode
      KONG_DECLARATIVE_CONFIG: /usr/local/kong/declarative/kong.yml
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
    volumes:
      - ./kong.yml:/usr/local/kong/declarative/kong.yml
    ports:
      - '8000:8000' # Public Gateway
      - '8001:8001' # Admin API
    networks:
      - kong-net
    depends_on:
      - products
      - customers
```

---

## 6. Run the System

Build and start everything:

```bash
docker compose up --build -d
```

Services:

- Products API â†’ `http://products:6010/api/products` (internal)
- Customers API â†’ `http://customers:6020/api/customers` (internal)
- Kong Admin API â†’ `http://localhost:8001`
- Kong Public Proxy â†’ `http://localhost:8000`

---

## 7. Test the Gateway

Instead of calling services directly, test via Kong:

```bash
curl http://localhost:8000/api/products
```

```json
[
  { "id": 1, "name": "Laptop", "price": 50000 },
  { "id": 2, "name": "Mobile", "price": 20000 }
]
```

```bash
curl http://localhost:8000/api/customers
```

```json
[
  {
    "id": 1,
    "name": "Vinod",
    "city": "Bangalore",
    "email": "vinod@vinod.co",
    "phone": "9731424784"
  },
  {
    "id": 2,
    "name": "John",
    "city": "Delhi",
    "email": "john@example.com",
    "phone": "9812345678"
  }
]
```

âœ… Both APIs now go **through Kong Gateway**.

---

## 8. Inspect Kong (Optional)

You can check what Kong loaded:

```bash
curl http://localhost:8001/services
curl http://localhost:8001/routes
```

---

## âœ… Summary

- We created **two Flask microservices** (Products & Customers).
- Ran them via **Docker Compose**.
- Put **Kong Gateway** in front of them.
- Used **declarative DB-less config (`kong.yml`)** to define routes.
- Fixed the **`strip_path` issue** so Flask services work correctly.
- Accessed all APIs via **one single gateway**: `http://localhost:8000/api/...`.

This setup is production-ready for local development. To scale, simply add more services in `kong.yml` and Kong will route them automatically.
