# Strategies for Upgrading Deployed APIs (Without Breaking Clients)

When APIs are deployed and in use by clients (mobile apps, partner integrations, frontends), **changes can be dangerous**.
If you remove or modify endpoints abruptly, clients may break.

That‚Äôs why upgrading APIs requires **careful planning and strategies**.

In this tutorial, we‚Äôll explore:

1. Why upgrading APIs is tricky
2. Strategies for safe upgrades
3. Demo with a Flask REST API

---

## 1. Why Upgrading APIs is Tricky?

Imagine we have a `Customer API`:

```json
{
  "id": 1,
  "name": "Vinod",
  "city": "Bangalore",
  "email": "vinod@vinod.co",
  "phone": "9731424784"
}
```

Now let‚Äôs say:

- You want to **rename `city` ‚Üí `location`**
- You want to **add photo URL**
- You want to **remove phone number**

If you simply change the API, existing apps that expect `city` or `phone` will break.
üëâ That‚Äôs why we need **upgrade strategies**.

---

## 2. API Upgrade Strategies

### Strategy 1: **Versioning** (most common)

- Add a version prefix: `/api/v1/customers`, `/api/v2/customers`.
- Old clients keep using **v1**, new clients switch to **v2**.
- Both can run in parallel until v1 is deprecated.

üëâ Example in Flask:

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route("/api/v1/customers")
def customers_v1():
    return jsonify([{"id": 1, "name": "Vinod", "city": "Bangalore", "email": "vinod@vinod.co", "phone": "9731424784"}])

@app.route("/api/v2/customers")
def customers_v2():
    return jsonify([{"id": 1, "name": "Vinod", "location": "Bangalore", "email": "vinod@vinod.co", "photo": "http://example.com/vinod.jpg"}])
```

‚úÖ Clients can choose when to migrate.

---

### Strategy 2: **Backward Compatibility**

- Keep supporting old fields until clients migrate.
- Add new fields alongside old ones.
- Deprecate gradually.

üëâ Example:

```python
@app.route("/api/customers")
def customers():
    return jsonify([
        {
            "id": 1,
            "name": "Vinod",
            "city": "Bangalore",        # old field (deprecated soon)
            "location": "Bangalore",    # new field
            "email": "vinod@vinod.co",
            "phone": "9731424784",      # will be removed later
            "photo": "http://example.com/vinod.jpg"
        }
    ])
```

‚úÖ Clients won‚Äôt break; they get both fields until you announce deprecation.

---

### Strategy 3: **Feature Flags / Query Parameters**

- Allow clients to ‚Äúopt-in‚Äù to new fields.
- Example: `GET /api/customers?version=2`.

üëâ Example:

```python
from flask import request

@app.route("/api/customers")
def customers_with_param():
    version = request.args.get("version", "1")
    if version == "2":
        return jsonify([{"id": 1, "name": "Vinod", "location": "Bangalore", "email": "vinod@vinod.co", "photo": "http://example.com/vinod.jpg"}])
    else:
        return jsonify([{"id": 1, "name": "Vinod", "city": "Bangalore", "email": "vinod@vinod.co", "phone": "9731424784"}])
```

‚úÖ Useful for gradual rollouts.

---

### Strategy 4: **Deprecation Notices**

- Announce breaking changes clearly (docs, headers).
- Send warnings in API responses.

üëâ Example (add a custom header):

```python
from flask import make_response

@app.route("/api/customers/deprecated")
def deprecated_customers():
    response = make_response(jsonify([{"id": 1, "name": "Vinod"}]))
    response.headers["Deprecation"] = "true"
    response.headers["Sunset"] = "2025-12-31"  # when it will stop working
    return response
```

Clients see headers and know when to upgrade.

---

### Strategy 5: **API Gateway Routing**

If you use an API Gateway (like Kong), you can:

- Run multiple API versions behind it.
- Route requests based on version path/header.
- Apply policies to gradually phase out old APIs.

---

## 3. Demo: Putting it Together

Let‚Äôs say we‚Äôre upgrading the **Customer API**:

- **v1** ‚Üí `city` and `phone`
- **v2** ‚Üí `location` and `photo`

Both run in parallel:

```python
@app.route("/api/v1/customers")
def customers_v1():
    return jsonify([{"id": 1, "name": "Vinod", "city": "Bangalore", "email": "vinod@vinod.co", "phone": "9731424784"}])

@app.route("/api/v2/customers")
def customers_v2():
    return jsonify([{"id": 1, "name": "Vinod", "location": "Bangalore", "email": "vinod@vinod.co", "photo": "http://example.com/vinod.jpg"}])
```

Clients using `v1` will not break.
New clients can migrate to `v2`.

Later, you announce:

- v1 will be deprecated on **2025-12-31**.
- v2 will be the only supported version from 2026.

---

## 4. Best Practices

- **Always communicate changes early** (docs, emails, headers).
- **Keep old versions alive** for a reasonable time.
- **Document differences clearly** between versions.
- **Automate testing** for both old & new versions.
- Use an **API Gateway** for easier version routing.

---

## 5. Summary

Upgrading deployed APIs without breaking clients requires strategy:

- Use **versioning** to run old & new APIs in parallel.
- Keep **backward compatibility** where possible.
- Provide **feature flags** for gradual rollout.
- Send **deprecation notices** in responses.
- Use an **API Gateway** to manage multiple versions cleanly.

By following these strategies, you ensure smooth API upgrades ‚Äî and happy clients üéØ
