# API Rate Limiting & Throttling in Flask with Flask-Limiter

APIs are powerful, but without **rate limiting** they can easily be abused. Imagine a malicious user (or even a buggy client) sending **thousands of requests per second** â€” your server could slow down, crash, or run up unexpected costs.

This is where **API rate limiting & throttling** comes in. In this tutorial, weâ€™ll explore:

- What API rate limiting is and why it matters
- Difference between **rate limiting** and **throttling**
- Setting up **Flask-Limiter** in a Flask REST API
- Applying limits globally, per-route, and per-user
- Using **custom keys** (like API keys, JWT user IDs, or IP addresses)
- Handling exceeded limits gracefully
- A practical **e-commerce product API example**

---

## Part 1: What is Rate Limiting?

- **Rate limiting** â†’ Restricts how many requests a client can make in a given timeframe (e.g., 100 requests per minute).
- **Throttling** â†’ Slows down or blocks requests once the rate limit is reached.

Example policies:

- Anonymous users: **10 requests/minute**
- Authenticated users: **100 requests/minute**
- Admins: **unlimited**

---

## Part 2: Install Dependencies

```bash
pip install flask flask-restful flask-limiter
```

---

## Part 3: Project Setup

**app.py**

```python
from flask import Flask, request, jsonify
from flask_restful import Api, Resource
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)
api = Api(app)

# Initialize Limiter
limiter = Limiter(
    get_remote_address,  # Default: limit by client IP
    app=app,
    default_limits=["100 per hour"]  # Global default
)
```

---

## Part 4: Example API (Products)

Weâ€™ll build a simple **e-commerce products API**.

```python
products = [
    {"id": 1, "name": "Amul Butter", "price": 50},
    {"id": 2, "name": "Tata Tea", "price": 200},
    {"id": 3, "name": "Parle-G Biscuits", "price": 10},
]

class ProductList(Resource):
    decorators = [limiter.limit("5 per minute")]  # Limit: 5 req/min per IP

    def get(self):
        return jsonify(products)

class ProductDetail(Resource):
    decorators = [limiter.limit("10 per minute")]

    def get(self, product_id):
        product = next((p for p in products if p["id"] == product_id), None)
        if product:
            return jsonify(product)
        return {"error": "Product not found"}, 404
```

---

## Part 5: Register Endpoints

```python
api.add_resource(ProductList, "/products")
api.add_resource(ProductDetail, "/products/<int:product_id>")
```

Run the app:

```bash
python app.py
```

---

## Part 6: Testing the Rate Limits

### Fetch all products (allowed: 5 requests/minute)

```bash
curl http://127.0.0.1:5000/products
```

If you exceed 5 requests per minute:

```json
{
  "error": "429 Too Many Requests: The rate limit is exceeded."
}
```

---

## Part 7: Different Limits for Different Users

Instead of limiting **per IP**, you can rate limit **per user** using API keys or JWT.

Example with **API key from headers**:

```python
def get_api_key():
    return request.headers.get("X-API-KEY") or get_remote_address

limiter = Limiter(
    key_func=get_api_key,
    app=app,
    default_limits=["50 per hour"]
)
```

Now:

- Each API key has its own quota
- Without a key â†’ falls back to IP address

---

## Part 8: Custom Limits for Roles (User vs Admin)

Letâ€™s simulate **role-based throttling**:

```python
USER_LIMITS = "10 per minute"
ADMIN_LIMITS = "100 per minute"

def role_based_limit():
    api_key = request.headers.get("X-API-KEY")
    if api_key == "admin123":
        return ADMIN_LIMITS
    return USER_LIMITS

class RoleBasedProducts(Resource):
    decorators = [limiter.limit(role_based_limit)]

    def get(self):
        return jsonify(products)

api.add_resource(RoleBasedProducts, "/rb-products")
```

- Normal user (X-API-KEY=anything else) â†’ 10 requests/min
- Admin (X-API-KEY=admin123) â†’ 100 requests/min

---

## Part 9: Handling Rate Limit Errors Gracefully

By default, Flask-Limiter returns a **429 Too Many Requests** error.
We can customize this:

```python
@app.errorhandler(429)
def ratelimit_handler(e):
    return jsonify(error="Too many requests. Please try again later.",
                   limit=str(e.description)), 429
```

---

## Part 10: Advanced Configurations

- **Burst + sustained limits**:

```python
@limiter.limit("10 per minute; 200 per day")
def get():
    return jsonify(products)
```

- **Exempt endpoints**:

```python
@limiter.exempt
def health_check():
    return {"status": "ok"}
```

- **Shared limits across multiple routes**:

```python
shared_limit = limiter.shared_limit("20 per minute", scope="products")

@app.route("/popular")
@shared_limit
def popular():
    return {"popular": ["Amul Butter", "Tata Tea"]}
```

---

## Conclusion

Weâ€™ve built a **Flask REST API with rate limiting & throttling** using Flask-Limiter.

âœ… Global rate limits
âœ… Per-route limits
âœ… Role-based (user/admin) limits
âœ… Custom error handling
âœ… Shared limits for groups of endpoints

With these strategies, you can **protect your APIs from abuse, ensure fair usage, and improve stability**.

---

ðŸ‘‰ Next steps:

- Store rate limit data in **Redis/Memcached** for distributed APIs
- Combine with **JWT authentication**
- Apply **dynamic limits** (different tiers: free vs paid users)
