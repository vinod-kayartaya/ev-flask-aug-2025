# Authentication & Authorization in REST APIs

Modern applications rarely live in isolation â€” they usually expose REST APIs consumed by web apps, mobile apps, or third-party systems. In such setups, **authentication (who are you?)** and **authorization (what can you do?)** are critical to ensure secure access.

In this tutorial, weâ€™ll explore the **three most popular mechanisms** used in industry:

- JSON Web Tokens (**JWT**)
- OAuth2
- Single Sign-On (**SSO**) with providers like **Google** or **Okta**

Weâ€™ll also build practical demos with Flask so you can implement these in your projects.

---

## Part 1: Authentication vs Authorization

Before diving into the details, letâ€™s clear the difference:

- **Authentication:** Verifying the identity of the user (e.g., logging in with username/password).
- **Authorization:** Determining what the authenticated user can access (e.g., admin can add products, customer can only view products).

Think of it like this:

- Entering a cinema hall: showing your ticket = **authentication**.
- Which seat youâ€™re allowed to sit in = **authorization**.

---

## Part 2: JWT Authentication

**JWT (JSON Web Token)** is one of the most common ways to secure REST APIs.

A JWT consists of 3 parts:

```
header.payload.signature
```

Example:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6...  (header)
eyJ1c2VyX2lkIjoxLCJyb2xlIjoiYWRtaW4ifQ... (payload)
jL2ZP7jAn5ZcUPeJ5qNcl7Up... (signature)
```

### Demo: JWT Authentication in Flask

Install dependencies:

```bash
pip install flask flask_sqlalchemy flask-jwt-extended flask-bcrypt
```

**app.py**

```python
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///users.db"
app.config["SECRET_KEY"] = "supersecret"
app.config["JWT_SECRET_KEY"] = "jwtsecret"

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(50), default="customer")

    def set_password(self, password):
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password_hash, password)

@app.route("/register", methods=["POST"])
def register():
    data = request.json
    user = User(username=data["username"])
    user.set_password(data["password"])
    db.session.add(user)
    db.session.commit()
    return jsonify({"message": "User registered successfully!"})

@app.route("/login", methods=["POST"])
def login():
    data = request.json
    user = User.query.filter_by(username=data["username"]).first()
    if user and user.check_password(data["password"]):
        token = create_access_token(identity=user.username, additional_claims={"role": user.role})
        return jsonify({"access_token": token})
    return jsonify({"error": "Invalid credentials"}), 401

@app.route("/protected", methods=["GET"])
@jwt_required()
def protected():
    identity = get_jwt_identity()
    return jsonify({"message": f"Welcome {identity['username']}!", "role": identity['role']})

if __name__ == "__main__":
    db.create_all()
    app.run(debug=True)
```

### Testing JWT

```bash
# Register
curl -X POST http://127.0.0.1:5000/register \
  -H "Content-Type: application/json" \
  -d '{"username": "vinod", "password": "mypassword"}'

# Login (get token)
curl -X POST http://127.0.0.1:5000/login \
  -H "Content-Type: application/json" \
  -d '{"username": "vinod", "password": "mypassword"}'

# Use token in protected route
curl http://127.0.0.1:5000/protected \
  -H "Authorization: Bearer <your_token_here>"
```

JWT is great for **stateless APIs** where the token is stored on the client (mobile app, frontend app).

---

## Part 3: OAuth2

JWT works well for internal systems, but when external apps need to access resources on behalf of a user, **OAuth2** is the industry standard.

- **Resource Owner** â†’ You (the user)
- **Client** â†’ The app requesting access (say Zomato wants your Google Contacts)
- **Authorization Server** â†’ Identity provider (Google, Facebook, Okta)
- **Resource Server** â†’ API hosting your data

### OAuth2 Example with Google

Weâ€™ll use `flask-dance` (simplifies OAuth2 in Flask).

Install:

```bash
pip install flask-dance
```

**google_auth.py**

```python
from flask import Flask, redirect, url_for
from flask_dance.contrib.google import make_google_blueprint, google

app = Flask(__name__)
app.secret_key = "supersecret"
app.config["GOOGLE_OAUTH_CLIENT_ID"] = "<your_client_id>"
app.config["GOOGLE_OAUTH_CLIENT_SECRET"] = "<your_client_secret>"

google_bp = make_google_blueprint(scope=["profile", "email"])
app.register_blueprint(google_bp, url_prefix="/login")

@app.route("/")
def index():
    if not google.authorized:
        return redirect(url_for("google.login"))
    resp = google.get("/oauth2/v2/userinfo")
    profile = resp.json()
    return f"Hello {profile['email']}! Welcome via Google OAuth2."
```

Now your users can **log in with Google**.

---

## Part 4: Single Sign-On (SSO)

SSO allows users to log in once and gain access to multiple applications.

Example: If your company uses **Okta** or **Google Workspace**, you can sign in once and access Gmail, Google Drive, Calendar, etc.

SSO is usually implemented using:

- **SAML (XML-based, older standard)**
- **OAuth2 + OpenID Connect (modern standard)**

### Demo: Flask + Okta SSO

1. Sign up for a free **Okta developer account** at [https://developer.okta.com](https://developer.okta.com).
2. Create a new **OIDC app** in Okta dashboard.
3. Configure redirect URI: `http://localhost:5000/authorization-code/callback`.
4. Install dependencies:

```bash
pip install flask flask_oidc
```

**okta_demo.py**

```python
from flask import Flask, jsonify
from flask_oidc import OpenIDConnect

app = Flask(__name__)
app.config.update({
    "SECRET_KEY": "supersecret",
    "OIDC_CLIENT_SECRETS": "client_secrets.json",
    "OIDC_RESOURCE_SERVER_ONLY": True,
    "OIDC_INTROSPECTION_AUTH_METHOD": "client_secret_post",
})

oidc = OpenIDConnect(app)

@app.route("/profile")
@oidc.require_login
def profile():
    user_info = oidc.user_getinfo(["email", "sub"])
    return jsonify(user_info)

if __name__ == "__main__":
    app.run(debug=True)
```

Here, `client_secrets.json` comes from your Okta application settings.

---

## JWT vs OAuth2 vs SSO

| Feature    | JWT                  | OAuth2                      | SSO (Okta/Google)           |
| ---------- | -------------------- | --------------------------- | --------------------------- |
| Use Case   | API authentication   | Third-party app access      | One login for multiple apps |
| Token Type | Self-contained JWT   | Access & refresh tokens     | SAML / OIDC tokens          |
| Storage    | Client (browser/app) | Authorization server        | Central identity provider   |
| Example    | Your internal API    | Login with Google on Zomato | Okta login for enterprise   |

---

## Conclusion

In this guide, we:

âœ… Implemented **JWT authentication** for REST APIs
âœ… Understood **OAuth2 flow** and integrated Google login
âœ… Explored **SSO with Okta**
âœ… Compared JWT, OAuth2, and SSO with real-world use cases

These three mechanisms cover **90% of authentication/authorization use cases** in modern systems.

---

ðŸ‘‰ Next steps you can try:

- Add **role-based authorization** to JWT routes.
- Extend **OAuth2 integration** to access Google Drive or Calendar.
- Deploy **Okta-based SSO** for your corporate apps.
