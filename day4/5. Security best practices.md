# Security Best Practices for Flask REST APIs (OWASP API Top 10)

APIs power everything — mobile apps, web apps, IoT devices, and microservices. But with great power comes **great responsibility**. A poorly secured API can expose sensitive data, open backdoors for attackers, and even take down your entire system.

To guide developers, the **OWASP Foundation** publishes the **OWASP API Security Top 10** list, which highlights the most critical risks for APIs.

In this tutorial, we’ll:

- Understand the **OWASP API Top 10**
- See how vulnerabilities apply to **Flask REST APIs**
- Learn **mitigation strategies** with **code examples**
- Build a mindset for **secure API development**

---

## API1:2019 – Broken Object Level Authorization (BOLA)

**Problem:**
Users can access data they shouldn’t (e.g., `/users/123/orders` shows another user’s orders).

**Fix:** Always check if the **authenticated user owns the resource**.

```python
@app.route("/orders/<int:order_id>")
@jwt_required()
def get_order(order_id):
    current_user = get_jwt_identity()
    order = Order.query.get(order_id)

    if not order or order.user_id != current_user["id"]:
        return {"error": "Unauthorized"}, 403

    return jsonify(order.to_dict())
```

---

## API2:2019 – Broken User Authentication

**Problem:** Weak or missing authentication lets attackers impersonate users.

**Fix:** Use strong **JWT authentication** with refresh tokens.

```python
from flask_jwt_extended import create_access_token, create_refresh_token

@app.route("/login", methods=["POST"])
def login():
    data = request.json
    user = User.query.filter_by(username=data["username"]).first()

    if user and user.check_password(data["password"]):
        return {
            "access_token": create_access_token(identity={"id": user.id}),
            "refresh_token": create_refresh_token(identity={"id": user.id})
        }
    return {"error": "Invalid credentials"}, 401
```

---

## API3:2019 – Excessive Data Exposure

**Problem:** Returning sensitive fields (e.g., passwords, tokens, internal IDs).

**Fix:** Only return necessary fields.

```python
def safe_user(user):
    return {"id": user.id, "username": user.username, "email": user.email}

@app.route("/users/<int:user_id>")
def get_user(user_id):
    user = User.query.get(user_id)
    return jsonify(safe_user(user))
```

---

## API4:2019 – Lack of Resources & Rate Limiting

**Problem:** No limits → API abused with brute force or DoS.

**Fix:** Use **Flask-Limiter**.

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(key_func=get_remote_address, app=app)

@app.route("/login", methods=["POST"])
@limiter.limit("5 per minute")
def login():
    ...
```

---

## API5:2019 – Broken Function Level Authorization

**Problem:** Users access admin endpoints (`/admin/delete-user`) without proper role checks.

**Fix:** Implement **RBAC (Role-Based Access Control)**.

```python
@app.route("/admin/users")
@jwt_required()
def list_users():
    current_user = get_jwt_identity()
    if current_user.get("role") != "admin":
        return {"error": "Forbidden"}, 403

    return jsonify([safe_user(u) for u in User.query.all()])
```

---

## API6:2019 – Mass Assignment

**Problem:** Attackers send extra JSON fields (`role=admin`) during registration.

**Fix:** Explicitly whitelist allowed fields.

```python
@app.route("/register", methods=["POST"])
def register():
    data = request.json
    user = User(
        username=data.get("username"),
        email=data.get("email"),
    )
    user.set_password(data.get("password"))
    db.session.add(user)
    db.session.commit()
    return {"message": "User registered successfully"}
```

---

## API7:2019 – Security Misconfiguration

**Problem:** Debug mode enabled in production, exposing secrets.

**Fix:**

- Disable `app.debug = True` in production.
- Store secrets in environment variables.

```python
import os

app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "fallback-secret")
```

---

## API8:2019 – Injection (SQL/NoSQL/Command Injection)

**Problem:** Unsafe query building allows SQL injection.

❌ Bad:

```python
user = db.session.execute(f"SELECT * FROM users WHERE id={user_id}")
```

✅ Good (SQLAlchemy ORM):

```python
user = User.query.filter_by(id=user_id).first()
```

---

## API9:2019 – Improper Assets Management

**Problem:** Old API versions remain public (`/api/v1/users` + `/api/v2/users`).

**Fix:**

- Document API versions clearly.
- Deprecate old versions.
- Use **API gateways** (Kong, Nginx, etc.) for routing.

---

## API10:2019 – Insufficient Logging & Monitoring

**Problem:** Attacks go unnoticed due to lack of logs.

**Fix:** Log security events (but avoid sensitive data).

```python
import logging
logging.basicConfig(filename="api.log", level=logging.INFO)

@app.after_request
def log_request(response):
    logging.info(f"{request.remote_addr} {request.method} {request.path} {response.status}")
    return response
```

---

## Security Checklist (Flask APIs)

✅ Use HTTPS (TLS) everywhere
✅ Secure authentication (JWT/OAuth2/SSO)
✅ Validate user input (Marshmallow / Pydantic)
✅ Apply rate limiting & throttling
✅ Restrict CORS origins in production
✅ Implement RBAC/ABAC
✅ Encrypt sensitive data (passwords with bcrypt)
✅ Keep dependencies updated
✅ Monitor API activity

---

## Conclusion

By applying the **OWASP API Top 10** practices, you:

- Protect your users’ data
- Defend against common API attacks
- Build **trustworthy APIs** that scale securely

Security is not a one-time fix — it’s a **continuous process**. Combine these best practices with **automated testing, monitoring, and audits** for maximum protection.
