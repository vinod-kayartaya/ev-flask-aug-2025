# File Upload Handling in REST APIs with Flask

File uploads are a common feature in modern applications — whether it’s profile pictures, product images, reports, or documents. In REST APIs, properly handling file uploads ensures **security, scalability, and usability**.

In this tutorial, we’ll explore **how to build a Flask REST API that supports file uploads**. We’ll cover:

- Understanding how file uploads work in REST APIs
- Setting up Flask and Flask-RESTful
- Handling single & multiple file uploads
- Securing file uploads (allowed extensions, size limits)
- Storing files locally and in a database (metadata)
- Testing with `curl` and Postman

We’ll use a **practical example**: uploading product images for an **e-commerce API** (with Indian products like "Tata Tea" and "Amul Butter").

---

## Part 1: How File Upload Works in REST APIs

When a client (web app, mobile app) uploads a file, it sends a `multipart/form-data` request:

- **Headers** specify the content type
- **Body** contains the file stream + additional fields (like product name)

Example request:

```http
POST /upload
Content-Type: multipart/form-data
Body:
    product_name = "Amul Butter"
    file = amul.jpg
```

---

## Part 2: Project Setup

Install dependencies:

```bash
pip install flask flask-restful flask-sqlalchemy werkzeug
```

Create `app.py`:

```python
import os
from flask import Flask, request
from flask_restful import Api, Resource
from flask_sqlalchemy import SQLAlchemy
from werkzeug.utils import secure_filename

# Configurations
UPLOAD_FOLDER = "uploads"
ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}

app = Flask(__name__)
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///products.db"
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER
app.config["MAX_CONTENT_LENGTH"] = 16 * 1024 * 1024  # 16 MB limit

api = Api(app)
db = SQLAlchemy(app)

# Ensure upload directory exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
```

---

## Part 3: Database Model

We’ll store **product info + image filename** in the database:

```python
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)
    image_filename = db.Column(db.String(200), nullable=True)

    def as_dict(self):
        return {"id": self.id, "name": self.name, "image_filename": self.image_filename}
```

---

## Part 4: Utility Function for File Validation

```python
def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS
```

---

## Part 5: API Resource for File Upload

```python
class ProductUpload(Resource):
    def post(self):
        if "file" not in request.files:
            return {"error": "No file part in request"}, 400

        file = request.files["file"]
        product_name = request.form.get("product_name")

        if not product_name:
            return {"error": "Product name is required"}, 400

        if file.filename == "":
            return {"error": "No selected file"}, 400

        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config["UPLOAD_FOLDER"], filename)
            file.save(filepath)

            # Save to DB
            product = Product(name=product_name, image_filename=filename)
            db.session.add(product)
            db.session.commit()

            return {"message": "File uploaded successfully", "product": product.as_dict()}, 201
        else:
            return {"error": "File type not allowed"}, 400
```

---

## Part 6: API Resource for Listing Products

```python
class ProductList(Resource):
    def get(self):
        products = Product.query.all()
        return [p.as_dict() for p in products]
```

---

## Part 7: Register Endpoints

```python
api.add_resource(ProductUpload, "/upload")
api.add_resource(ProductList, "/products")

if __name__ == "__main__":
    db.create_all()
    app.run(debug=True)
```

---

## Part 8: Testing the API

### Upload a product image

```bash
curl -X POST http://127.0.0.1:5000/upload \
  -F "product_name=Amul Butter" \
  -F "file=@amul.jpg"
```

Response:

```json
{
  "message": "File uploaded successfully",
  "product": {
    "id": 1,
    "name": "Amul Butter",
    "image_filename": "amul.jpg"
  }
}
```

### Get product list

```bash
curl http://127.0.0.1:5000/products
```

Response:

```json
[
  {
    "id": 1,
    "name": "Amul Butter",
    "image_filename": "amul.jpg"
  }
]
```

---

## Part 9: Handling Multiple File Uploads

You can support multiple file uploads like this:

```python
class MultiUpload(Resource):
    def post(self):
        files = request.files.getlist("files")
        product_name = request.form.get("product_name")

        saved_files = []
        for file in files:
            if file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                filepath = os.path.join(app.config["UPLOAD_FOLDER"], filename)
                file.save(filepath)
                saved_files.append(filename)

        return {"message": "Files uploaded", "files": saved_files}
```

Test:

```bash
curl -X POST http://127.0.0.1:5000/multi-upload \
  -F "product_name=Tata Tea" \
  -F "files=@tata1.jpg" \
  -F "files=@tata2.jpg"
```

---

## Part 10: Security Best Practices

1. **Allowed file extensions** – prevent malicious uploads.
2. **Max file size limit** – avoid denial-of-service attacks.
3. **Use `secure_filename()`** – avoid directory traversal attacks.
4. **Store only filename in DB, not raw file data** (unless you use cloud storage like AWS S3).
5. **Virus scanning (ClamAV, external service)** for production apps.

---

## Conclusion

We’ve built a **Flask REST API** that supports:

✅ Single & multiple file uploads
✅ Metadata storage in a database
✅ Secure handling with filename checks and size limits
✅ Easy testing with `curl` or Postman

With this foundation, you can extend to:

- Storing files on **AWS S3 / Google Cloud Storage**
- Serving uploaded files via a **CDN**
- Adding **JWT authentication** before file upload
